<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>ComplexMethod:CordaRPCClient.kt$CordaRPCClientConfiguration$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// This is the general function that transforms a client side RPC to internal Artemis messages. override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?): Any?</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$private fun attemptReconnect()</ID>
    <ID>ComplexMethod:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$ private tailrec fun establishConnectionWithRetry( retryInterval: Duration, roundRobinIndex: Int = 0, retries: Int = -1 ): CordaRPCConnection?</ID>
    <ID>EmptyCatchBlock:RPCClientProxyHandler.kt$RPCClientProxyHandler${}</ID>
    <ID>EmptyClassBlock:CordaRPCClient.kt$CordaRPCClient.Companion${}</ID>
    <ID>ForbiddenComment:CordaRPCClient.kt$CordaRPCClientConfiguration$// TODO: acquire this value from Network Map when supported.</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClient$( private val hostAndPort: NetworkHostAndPort?, private val haAddressPool: List&lt;NetworkHostAndPort&gt;, private val configuration: CordaRPCClientConfiguration = CordaRPCClientConfiguration.DEFAULT, private val sslConfiguration: ClientRpcSslOptions? = null, private val classLoader: ClassLoader? = null, private val customSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt;? = null )</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClient$( username: String, password: String, externalTrace: Trace?, impersonatedActor: Actor?, targetLegalIdentity: CordaX500Name?, gracefulReconnect: GracefulReconnect? = null )</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClientConfiguration$( /** * The maximum retry interval for re-connections. The client will retry connections if the host is lost with * ever increasing spacing until the max is reached. The default is 3 minutes. */ open val connectionMaxRetryInterval: Duration = 3.minutes, /** * The minimum protocol version required from the server. This is equivalent to the node's platform version * number. If this minimum version is not met, an exception will be thrown at startup. If you use features * introduced in a later version, you can bump this to match the platform version you need and get an early * check that runs before you do anything. * * If you leave it at the default then things will work but attempting to use an RPC added in a version later * than the server supports will throw [UnsupportedOperationException]. * * The default value is whatever version of Corda this RPC library was shipped as a part of. Therefore if you * use the RPC library from Corda 4, it will by default only connect to a node of version 4 or above. */ open val minimumServerProtocolVersion: Int = PLATFORM_VERSION, /** * If set to true the client will track RPC call sites (default is false). If an error occurs subsequently * during the RPC or in a returned Observable stream the stack trace of the originating RPC will be shown as * well. Note that constructing call stacks is a moderately expensive operation. */ open val trackRpcCallSites: Boolean = java.lang.Boolean.getBoolean("net.corda.client.rpc.trackRpcCallSites"), /** * The interval of unused observable reaping. Leaked Observables (unused ones) are detected using weak references * and are cleaned up in batches in this interval. If set too large it will waste server side resources for this * duration. If set too low it wastes client side cycles. The default is to check once per second. */ open val reapInterval: Duration = 1.seconds, /** * The number of threads to use for observations for executing [Observable.onNext]. This only has any effect * if [observableExecutor] is null (which is the default). The default is 4. */ open val observationExecutorPoolSize: Int = 4, /** * This property is no longer used and has no effect. * @suppress */ @Deprecated("This field is no longer used and has no effect.") open val cacheConcurrencyLevel: Int = 1, /** * The base retry interval for reconnection attempts. The default is 5 seconds. */ open val connectionRetryInterval: Duration = 5.seconds, /** * The retry interval multiplier for exponential backoff. The default is 1.5 */ open val connectionRetryIntervalMultiplier: Double = 1.5, /** * Maximum reconnect attempts on failover or disconnection. * Any negative value would mean that there will be an infinite number of reconnect attempts. */ open val maxReconnectAttempts: Int = unlimitedReconnectAttempts, /** * Maximum size of RPC responses, in bytes. Default is 10mb. */ open val maxFileSize: Int = 10485760, // 10 MiB maximum allowed file size for attachments, including message headers. // TODO: acquire this value from Network Map when supported. /** * The cache expiry of a deduplication watermark per client. Default is 1 day. */ open val deduplicationCacheExpiry: Duration = 1.days )</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClientConfiguration$( connectionMaxRetryInterval: Duration = this.connectionMaxRetryInterval, minimumServerProtocolVersion: Int = this.minimumServerProtocolVersion, trackRpcCallSites: Boolean = this.trackRpcCallSites, reapInterval: Duration = this.reapInterval, observationExecutorPoolSize: Int = this.observationExecutorPoolSize, cacheConcurrencyLevel: Int = this.cacheConcurrencyLevel, connectionRetryInterval: Duration = this.connectionRetryInterval, connectionRetryIntervalMultiplier: Double = this.connectionRetryIntervalMultiplier, maxReconnectAttempts: Int = this.maxReconnectAttempts, maxFileSize: Int = this.maxFileSize, deduplicationCacheExpiry: Duration = this.deduplicationCacheExpiry )</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCConnection.Companion$( username: String, password: String, addresses: List&lt;NetworkHostAndPort&gt;, rpcConfiguration: CordaRPCClientConfiguration, gracefulReconnect: GracefulReconnect, sslConfiguration: ClientRpcSslOptions? = null, classLoader: ClassLoader? = null )</ID>
    <ID>LongParameterList:RPCClient.kt$RPCClient$( rpcOpsClass: Class&lt;I&gt;, username: String, password: String, externalTrace: Trace? = null, impersonatedActor: Actor? = null, targetLegalIdentity: CordaX500Name? = null )</ID>
    <ID>LongParameterList:RPCClientProxyHandler.kt$RPCClientProxyHandler$( private val rpcConfiguration: CordaRPCClientConfiguration, private val rpcUsername: String, private val rpcPassword: String, private val serverLocator: ServerLocator, private val clientAddress: SimpleString, private val rpcOpsClass: Class&lt;out RPCOps&gt;, serializationContext: SerializationContext, private val sessionId: Trace.SessionId, private val externalTrace: Trace?, private val impersonatedActor: Actor?, private val targetLegalIdentity: CordaX500Name?, private val cacheFactory: NamedCacheFactory = ClientCacheFactory() )</ID>
    <ID>LongParameterList:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps$( nodeHostAndPorts: List&lt;NetworkHostAndPort&gt;, username: String, password: String, rpcConfiguration: CordaRPCClientConfiguration, gracefulReconnect: GracefulReconnect = GracefulReconnect(), sslConfiguration: ClientRpcSslOptions? = null, classLoader: ClassLoader? = null, observersPool: ExecutorService )</ID>
    <ID>LoopWithTooManyJumpStatements:RPCClientProxyHandler.kt$RPCClientProxyHandler$while (shouldRetry(reconnectAttempt)) { val transport = serverLocator.staticTransportConfigurations.let { it[(reconnectAttempt - 1) % it.size] } log.debug { "Trying to connect using ${transport.params}" } try { if (!serverLocator.isClosed) { sessionFactory = serverLocator.createSessionFactory(transport) } else { log.warn("Stopping reconnect attempts.") log.debug { "Server locator is closed or garbage collected. Proxy may have been closed during reconnect." } break } } catch (e: ActiveMQException) { try { Thread.sleep(retryInterval.toMillis()) } catch (e: InterruptedException) {} // Could not connect, try with next server transport. reconnectAttempt++ retryInterval = minOf(maxRetryInterval, retryInterval.times(rpcConfiguration.connectionRetryIntervalMultiplier.toLong())) continue } log.debug { "Connected successfully after $reconnectAttempt attempts using ${transport.params}." } log.info("RPC server available.") sessionFactory!!.addFailoverListener(haFailoverHandler) initSessions() startSessions() sendingEnabled.set(true) break }</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClient$128</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$3</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$5</ID>
    <ID>MagicNumber:RPCClient.kt$RPCClient$30000</ID>
    <ID>MagicNumber:RPCClient.kt$RPCClient$60000</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$1000</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$16384</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps$4</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$1000</ID>
    <ID>NestedBlockDepth:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>NewLineAtEndOfFile:ClientCacheFactory.kt$net.corda.client.rpc.internal.ClientCacheFactory.kt</ID>
    <ID>NewLineAtEndOfFile:CordaRPCClient.kt$net.corda.client.rpc.CordaRPCClient.kt</ID>
    <ID>NewLineAtEndOfFile:PermissionException.kt$net.corda.client.rpc.PermissionException.kt</ID>
    <ID>NewLineAtEndOfFile:RPCConnection.kt$net.corda.client.rpc.RPCConnection.kt</ID>
    <ID>NewLineAtEndOfFile:RPCUtils.kt$net.corda.client.rpc.internal.RPCUtils.kt</ID>
    <ID>NewLineAtEndOfFile:ReconnectingObservable.kt$net.corda.client.rpc.internal.ReconnectingObservable.kt</ID>
    <ID>ReturnCount:RPCClientProxyHandler.kt$RPCClientProxyHandler$// This is the general function that transforms a client side RPC to internal Artemis messages. override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?): Any?</ID>
    <ID>ReturnCount:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$ private tailrec fun establishConnectionWithRetry( retryInterval: Duration, roundRobinIndex: Int = 0, retries: Int = -1 ): CordaRPCConnection?</ID>
    <ID>SpreadOperator:RPCClient.kt$RPCClient$(*haPoolTransportConfigurations.toTypedArray())</ID>
    <ID>SpreadOperator:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$(reconnectingRPCConnection.proxy, *(args ?: emptyArray()))</ID>
    <ID>TooGenericExceptionCaught:RPCClient.kt$RPCClient$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCClientProxyHandler.kt$RPCClientProxyHandler$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCClientProxyHandler.kt$RPCClientProxyHandler$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ReconnectingObservable.kt$ReconnectingObservable.ReconnectingSubscriber$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Utils.kt$e: Exception</ID>
    <ID>TooManyFunctions:RPCClientProxyHandler.kt$RPCClientProxyHandler : InvocationHandler</ID>
  </CurrentIssues>
</SmellBaseline>
